# Copyright 2015 Philip Boulain <philip.boulain@smoothwall.net>
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License v3 or later.
# See LICENSE.txt for details.
use warnings;
use strict;

package Plumage::Model::Collection;

=head1 Plumage::Model::Collection

Generic CRUD/REST-oriented collection concept for the model.
This is used where collections are exposed as such via the API, because it
makes sense to individually address (and modify) the components.
It is not used for e.g. run parameters since they are always treated as a
complete list, to avoid needless adaptation friction in the controller.

Because the model is filesystem-backed, what this actually stores is paths, and
it only manages IDs. It is up to users of this class to actually persist the
data of elements in the collection, usually by in subdirectories returned by
at(), although directly as files also works.

Designed for has-a, not is-a, composition.

=cut

use File::Path qw();
use File::Slurp qw();
use IO::Dir;

=head2 new(store_dir)

The constructor takes the base path for the collection's data.
Other Model packages construct these internally; end users of the Model do not.

=cut

sub new {
	my ($class, $store_dir) = @_;
	return bless({
		store_dir => $store_dir,
	}, $class);
}

# Private namespaced function to validate that a provided ID is safe, i.e. not
# going to reference filesystem paths outside of the store directory or
# conflict with reserved names. (It does not care in the slightest about things
# like shell metacharacters.)
# Returns a boolean indicating if this is the case.
# This is a looser case than the supporting file validation. While
# autogenerated IDs from create() are unique simple-numeric, insert_at() allows
# collections to also function like maps.
sub _validate_id {
	my ($id) = @_;
	return (($id !~ m!/!) && ($id !~ m!^\.!));
}

=head2 list()

Returns a list of identifiers in this collection.

=cut

sub list {
	my ($self) = @_;
	my $dir = IO::Dir->new($self->{store_dir});
	die "Couldn't open store directory: $!\n" unless defined $dir;
	my @list = grep { _validate_id($_) } $dir->read();
	return @list;
}

=head2 at(id)

Returns either the path for the ID specified, or undefined if no element by
that ID exists.

This is suitable for both retrieve and update operations.

=cut

sub at {
	my ($self, $id) = @_;
	return undef unless _validate_id($id);
	my $sub_dir = $self->{store_dir}."/$id";

	if(-e $sub_dir) {
		return $sub_dir;
	} else {
		return;
	}
}

=head2 insert_at(id)

Like at(), but returns the path for the ID even if it does not exist.

Throws if the ID is hidden or contains path components.
This is an important distinction from at(), which will just consider them
non-existant for uniform 'not found' reporting with arbitrary user input.

Note that this doesn't actually I<write> anything itself.
You are expected to mkdir(), write_file(), or such the result.

=cut

sub insert_at {
	my ($self, $id) = @_;
	die "Unsafe ID '$id' in collection\n" unless _validate_id($id);
	return $self->{store_dir}."/$id";
}

=head2 create()

Generates a unique, non-repeating ID and returns it.

For symmetry with delete(), this B<does> mkdir the path for the ID, since its
use cases are for autonumbered state subdirectories.

=cut

sub create {
	my ($self) = @_;
	my $store_dir = $self->{store_dir};
	my $next_file = "$store_dir/.next";

	# Read the remembered next ID, if any.
	my $next_id = File::Slurp::read_file($next_file, err_mode => 'quiet');

	if((defined $next_id) && ($next_id !~ /^[0-9]+$/)) {
		# For some reason it was corrupt. This case is supported mostly to
		# avoid next-file tampering from becoming an arbitrary mkdir below.
		# Note that the next ID is *always* numeric; this check is tighter than
		# _validate_id().
		warn "Next-ID file for $store_dir was corrupt!";
		$next_id = undef;
	}

	unless(defined $next_id) {
		# The normal case for this is we haven't lazily-created the next-file
		# yet. However, for robustness, make sure we're not overlapping any
		# existing items.
		# This code overlaps with Common's state directory handling.
		my $dir = IO::Dir->new($store_dir);
		die "Couldn't open store directory: $!\n" unless defined $dir;
		$next_id = 0;
		foreach my $entry ($dir->read()) {
			if($entry =~ /^[0-9]+$/) {
				if($next_id <= $entry) { $next_id = $entry + 1; }
			}
		}
	}

	# Use the next ID, then increment it
	my $id = $next_id++;
	mkdir "$store_dir/$id"
		or die "Creating store subdirectory failed: $!\n";

	# Remember the next ID for next time
	File::Slurp::write_file($next_file, $next_id);

	return $id;
}

=head2 delete(id)

Removes an ID from the collection, and deletes everything under its directory.
Returns undef if it did not exist, a true value otherwise.
Throws on filesystem errors.

=cut

sub delete {
	my ($self, $id) = @_;
	return undef unless _validate_id($id);
	my $sub_dir = $self->{store_dir}."/$id";

	return undef unless -e $sub_dir;

	my $rmerrors;
	File::Path::remove_tree($sub_dir, {
		safe => 1, # don't -f; shouldn't need to chmod anything
		error => \$rmerrors,
	});

	# Consult File::Path's POD for the structure we're unpicking here
	if(@$rmerrors) {
		my @errors;
		foreach my $rmerror (@$rmerrors) {
			foreach my $file (keys %$rmerror) {
				push @errors, "$file (".$rmerror->{$file}.')';
			}
		}
		my $errorsummary = join('; ', @errors);
		die "Deleting store files failed: $errorsummary\n";
	}

	return 1;
}

1;
